
export default [
  {
    "content": "# Getting Started With Generic Type\r\n\r\nGeneric Type is a feature in programming that allows you to create classes, functions, and data structures that can operate on any data type without sacrificing type safety.\r\n\r\nWithout knowing generic type, you might use `any` in Typescript.\r\n\r\n```typescript\r\nfunction returnWhatIsPassed(value: any) {\r\n    return value\r\n}\r\n```\r\n\r\nHowever, using any sacrifices type safety.\r\n\r\n```typescript\r\nfunction returnWhatIsPassed<T>(value: T): T {\r\n    return value\r\n}\r\n```\r\n\r\nThis function works with any data type while ensuring that the input and output are of the same type.\r\n\r\n## Example of Generic Type in Action\r\n\r\n```typescript\r\nfunction getFirstElement<T>(arr: T[]): T {\r\n    return arr[0]\r\n}\r\n\r\nlet firstNumber = getFirstElement<number>([1, 2, 3]) // 1\r\nlet firstString = getFirstElement<string>([\"a\", \"b\", \"c\"]) // \"a\"\r\n```\r\n\r\nIn this example, getFirstElement works with both numbers and strings while maintaining type safety.\r\n\r\nUsing generic types enhances the flexibility, safety, and readability of your code. Instead of relying on any, generics ensure that your functions and classes work correctly with different data types while maintaining clear and predictable behavior.",
    "title": "Getting Started With Generic Type",
    "summary": "Let's Master Typing in With Generic Type for Type Safe Code",
    "tags": [
      "typescript",
      "generic-type",
      "types"
    ],
    "keywords": [
      "typescript",
      "generic-type",
      "types"
    ],
    "publishedDate": new Date("2025-02-25T07:08:55.133Z"),
    "_meta": {
      "filePath": "getting-started-with-generic-type.md",
      "fileName": "getting-started-with-generic-type.md",
      "directory": ".",
      "extension": "md",
      "path": "getting-started-with-generic-type"
    },
    "html": "<h1>Getting Started With Generic Type</h1>\n<p>Generic Type is a feature in programming that allows you to create classes, functions, and data structures that can operate on any data type without sacrificing type safety.</p>\n<p>Without knowing generic type, you might use <code>any</code> in Typescript.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">returnWhatIsPassed</span>(<span class=\"hljs-params\"><span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">any</span></span>) {\r\n    <span class=\"hljs-keyword\">return</span> value\r\n}\n</code></pre>\n<p>However, using any sacrifices type safety.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">function</span> returnWhatIsPassed&#x3C;T>(<span class=\"hljs-attr\">value</span>: T): T {\r\n    <span class=\"hljs-keyword\">return</span> value\r\n}\n</code></pre>\n<p>This function works with any data type while ensuring that the input and output are of the same type.</p>\n<h2>Example of Generic Type in Action</h2>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">function</span> getFirstElement&#x3C;T>(<span class=\"hljs-attr\">arr</span>: T[]): T {\r\n    <span class=\"hljs-keyword\">return</span> arr[<span class=\"hljs-number\">0</span>]\r\n}\r\n\r\n<span class=\"hljs-keyword\">let</span> firstNumber = getFirstElement&#x3C;<span class=\"hljs-built_in\">number</span>>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]) <span class=\"hljs-comment\">// 1</span>\r\n<span class=\"hljs-keyword\">let</span> firstString = getFirstElement&#x3C;<span class=\"hljs-built_in\">string</span>>([<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"c\"</span>]) <span class=\"hljs-comment\">// \"a\"</span>\n</code></pre>\n<p>In this example, getFirstElement works with both numbers and strings while maintaining type safety.</p>\n<p>Using generic types enhances the flexibility, safety, and readability of your code. Instead of relying on any, generics ensure that your functions and classes work correctly with different data types while maintaining clear and predictable behavior.</p>"
  },
  {
    "content": "# My Plan For 2025\r\n\r\nI am currently a college student but as an developer and also teen, I find passionate about coding and programming. When it's come to my goal, it have to achieve them.\r\n\r\nLearning Programming languages are not goal, they are tools that are used to solve problems.\r\n\r\n## My Goals\r\n\r\nI had myself declare some goals!\r\n\r\n### Data Structure and Algorithms\r\n\r\nYes, DSA! Mastering data structures and algorithms is one of my top priorities. Not only are these essential for technical job interviews, but they are also incredibly useful for solving real-world problems in software development and building efficient systems.\r\n\r\n### NeoVim (HELL YEAH)\r\n\r\nI’ve been using VSCode for the past five years, and while it’s great, I’ve been inspired by people using NeoVim or Vim editors with incredible speed and efficiency. These editors are highly customizable—you can set key mappings to match your preferences, making coding faster.\r\n\r\n### System Design\r\n\r\nI enjoy diving deep into over-engineering projects, and system design fascinates me. Learning system design will help me understand how large-scale systems and tools work. This knowledge will be valuable for real-world projects, and it aligns with my long-term goal of becoming a system architect.\r\n\r\n### Learning English\r\n\r\nYes, you heard that right. As a Burmese from Myanmar, I feel that my English skills are not yet where I want them to be. Since my dream is to work abroad and eventually earn a six-figure salary, improving my English proficiency is crucial. I want to communicate confidently and effectively in both personal and professional settings.",
    "title": "My Goals and Plan for 2025",
    "summary": "This article outlines my goals for 2025 and the steps I plan to take to achieve them",
    "tags": [
      "myself"
    ],
    "keywords": [
      "Winning Life",
      "Self",
      "Goal"
    ],
    "publishedDate": new Date("2025-01-09T00:00:00.000Z"),
    "_meta": {
      "filePath": "my-plan-for-2025.md",
      "fileName": "my-plan-for-2025.md",
      "directory": ".",
      "extension": "md",
      "path": "my-plan-for-2025"
    },
    "html": "<h1>My Plan For 2025</h1>\n<p>I am currently a college student but as an developer and also teen, I find passionate about coding and programming. When it's come to my goal, it have to achieve them.</p>\n<p>Learning Programming languages are not goal, they are tools that are used to solve problems.</p>\n<h2>My Goals</h2>\n<p>I had myself declare some goals!</p>\n<h3>Data Structure and Algorithms</h3>\n<p>Yes, DSA! Mastering data structures and algorithms is one of my top priorities. Not only are these essential for technical job interviews, but they are also incredibly useful for solving real-world problems in software development and building efficient systems.</p>\n<h3>NeoVim (HELL YEAH)</h3>\n<p>I’ve been using VSCode for the past five years, and while it’s great, I’ve been inspired by people using NeoVim or Vim editors with incredible speed and efficiency. These editors are highly customizable—you can set key mappings to match your preferences, making coding faster.</p>\n<h3>System Design</h3>\n<p>I enjoy diving deep into over-engineering projects, and system design fascinates me. Learning system design will help me understand how large-scale systems and tools work. This knowledge will be valuable for real-world projects, and it aligns with my long-term goal of becoming a system architect.</p>\n<h3>Learning English</h3>\n<p>Yes, you heard that right. As a Burmese from Myanmar, I feel that my English skills are not yet where I want them to be. Since my dream is to work abroad and eventually earn a six-figure salary, improving my English proficiency is crucial. I want to communicate confidently and effectively in both personal and professional settings.</p>"
  },
  {
    "content": "# What's new in Tailwind V4 Beta\r\n\r\nTailwind CSS ရဲ့ v4.0 Beta 1 version ဟာ release လုပ်ခဲ့ပြီဖြစ်ပါတယ်။\r\nOxide လို့ခေါ်တဲ့ Tailwind CSS Engine တစ်ခုလုံးကို Rust နဲ့ Rewrite လုပ်ထားပါတယ်။ TailwindCSS ရဲ့ performance က 2x ပိုမြန်လာပါတယ်။\r\n\r\nOxide Engine ဟာဆိုရင် Lightning CSS ကိုသုံးထားတာမလို့ Performance ရော, Build Size ရောပိုကောင်းလာပါတယ်။\r\n\r\n![Lightning CSS Comparison](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Il4X5gZ2aa082CN6Rk8kUQ.png)\r\n\r\n```css\r\n@tailwind base;\r\n@tailwind components;\r\n@tailwind utilities;\r\n```\r\n\r\nလို့ import လုပ်စရာမလိုတော့ပါဘူး\r\n\r\n```css\r\n@import 'tailwindcss';\r\n```\r\n\r\nဆိုပြီး single-line နဲ့ Tailwind CSS ကို import လုပ်လို့ရပါပြီ\r\n\r\nTailwind config မှာဆိုရင်လည်း content ဆိုပြီး declare လုပ်စရာမလိုတော့ပါဘူး Tailwind CSS Team က automatic content detection algorithm ကိုထည့်ပေးထားပါတယ်။\r\n\r\nTailwind CSS Team က CSS-based configuration ကို prototyping လုပ်နေပါတယ်။ နောက်ပိုင်းကျရင် CSS ထဲမှာ configuration တွေထည့်လို့ရတော့မှာပါ။\r\n\r\n```css\r\n/* app.css */\r\n/* experimental */\r\n@import 'tailwindcss';\r\n\r\n@import \"./fonts\" layer(base)\r\n\r\n@theme {\r\n  --font-family-sans: 'Roboto', 'sans-serif';\r\n  --font-family-monument: 'Monument', 'sans-serif';\r\n\r\n  --color-primary: #0D6EFD;\r\n  --color-secondary: #6D28D9;\r\n}\r\n```\r\n\r\nTailwind CSS Beta မှာဆိုရင် Oxide Engine ကို သိသိသာသာ improvement အနေနဲ့ update ပေးသွားပါတယ်။\r\n\r\n[Get Started With Tailwind v4 Beta](https://tailwindcss.com/docs/v4-beta)\r\n\r\n## Reference\r\n\r\n1. [What’s Tailwind Oxide Engine? The Next Evolution of Tailwind CSS (Marek Bombera, 2023)](https://medium.com/@bomber.marek/whats-tailwind-oxide-engine-the-next-evolution-of-tailwind-css-32e7ef8e19a1)",
    "title": "What's new in Tailwind V4 beta.",
    "summary": "Tailwind CSS just drop a messive update",
    "tags": [
      "tailwindcss",
      "css",
      "update"
    ],
    "keywords": [
      "Tailwind CSS",
      "Tailwind CSS Update",
      "Tailwind Beta",
      "Tailwind v4 beta"
    ],
    "publishedDate": new Date("2024-11-28T03:21:02.577Z"),
    "_meta": {
      "filePath": "tailwind-v4-beta-my.md",
      "fileName": "tailwind-v4-beta-my.md",
      "directory": ".",
      "extension": "md",
      "path": "tailwind-v4-beta-my"
    },
    "html": "<h1>What's new in Tailwind V4 Beta</h1>\n<p>Tailwind CSS ရဲ့ v4.0 Beta 1 version ဟာ release လုပ်ခဲ့ပြီဖြစ်ပါတယ်။\r\nOxide လို့ခေါ်တဲ့ Tailwind CSS Engine တစ်ခုလုံးကို Rust နဲ့ Rewrite လုပ်ထားပါတယ်။ TailwindCSS ရဲ့ performance က 2x ပိုမြန်လာပါတယ်။</p>\n<p>Oxide Engine ဟာဆိုရင် Lightning CSS ကိုသုံးထားတာမလို့ Performance ရော, Build Size ရောပိုကောင်းလာပါတယ်။</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Il4X5gZ2aa082CN6Rk8kUQ.png\" alt=\"Lightning CSS Comparison\"></p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-keyword\">@tailwind</span> base;\r\n<span class=\"hljs-keyword\">@tailwind</span> components;\r\n<span class=\"hljs-keyword\">@tailwind</span> utilities;\n</code></pre>\n<p>လို့ import လုပ်စရာမလိုတော့ပါဘူး</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">'tailwindcss'</span>;\n</code></pre>\n<p>ဆိုပြီး single-line နဲ့ Tailwind CSS ကို import လုပ်လို့ရပါပြီ</p>\n<p>Tailwind config မှာဆိုရင်လည်း content ဆိုပြီး declare လုပ်စရာမလိုတော့ပါဘူး Tailwind CSS Team က automatic content detection algorithm ကိုထည့်ပေးထားပါတယ်။</p>\n<p>Tailwind CSS Team က CSS-based configuration ကို prototyping လုပ်နေပါတယ်။ နောက်ပိုင်းကျရင် CSS ထဲမှာ configuration တွေထည့်လို့ရတော့မှာပါ။</p>\n<pre><code class=\"hljs language-css\"><span class=\"hljs-comment\">/* app.css */</span>\r\n<span class=\"hljs-comment\">/* experimental */</span>\r\n<span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">'tailwindcss'</span>;\r\n\r\n<span class=\"hljs-keyword\">@import</span> <span class=\"hljs-string\">\"./fonts\"</span> layer(base)\r\n\r\n@theme {\r\n  <span class=\"hljs-attr\">--font-family-sans</span>: <span class=\"hljs-string\">'Roboto'</span>, <span class=\"hljs-string\">'sans-serif'</span>;\r\n  <span class=\"hljs-attr\">--font-family-monument</span>: <span class=\"hljs-string\">'Monument'</span>, <span class=\"hljs-string\">'sans-serif'</span>;\r\n\r\n  <span class=\"hljs-attr\">--color-primary</span>: <span class=\"hljs-number\">#0D6EFD</span>;\r\n  <span class=\"hljs-attr\">--color-secondary</span>: <span class=\"hljs-number\">#6D28D9</span>;\r\n}\n</code></pre>\n<p>Tailwind CSS Beta မှာဆိုရင် Oxide Engine ကို သိသိသာသာ improvement အနေနဲ့ update ပေးသွားပါတယ်။</p>\n<p><a href=\"https://tailwindcss.com/docs/v4-beta\">Get Started With Tailwind v4 Beta</a></p>\n<h2>Reference</h2>\n<ol>\n<li><a href=\"https://medium.com/@bomber.marek/whats-tailwind-oxide-engine-the-next-evolution-of-tailwind-css-32e7ef8e19a1\">What’s Tailwind Oxide Engine? The Next Evolution of Tailwind CSS (Marek Bombera, 2023)</a></li>\n</ol>"
  },
  {
    "content": "# Big O Notation ဆိုတာဘာလဲ\r\n\r\n![Big O Notation Cheat Sheet](https://www.bigocheatsheet.com/img/big-o-complexity-chart.png)\r\n\r\nBig O Notation ဆိုတာက algorithm selection နှင့် performance tuning လုပ်တဲ့အခါမှာ သုံးပါတယ်။ Big O Notation မှာ Time Complexity နဲ့  Space Complexity ဆိုပြီး နှစ်ခုရှိပါတယ်။\r\n\r\nTime Complexity ဆိုတာက algorithms တစ်ခုက input size ပေါ် မှာမူတည်ပြီး algorithm ကို run estimated duration ကိုပြောတာပါ။\r\n\r\nSpace complexity ဆိုတာ algorithm တစ်ခုကို run တဲ့အခါမှာ required memory amount (bytes, kilobytes, etc.) ကို input size (n) ပေါ် မှာမူတည်ပြီး ခန့်မှုန်းတဲ့နေရာမှာသုံး ပါတယ်။\r\n\r\nBig O Notation ဆိုတာကဟာ Programmer တိုင်းသိထားသင့်တဲ့ mathematical notation တစ်ခုဖြစ်ပါတယ်။ Code ရေးတတ်တာ alone နဲ့ မလုံလောက်ဘူး။ Algorithm ရဲ့ performance နားလည်ဖို့ Big O Notation သိထားသင့်တယ်။\r\n\r\n## Time Complexity တွက်ခြင်း\r\n\r\nTime Complexity ဆိုတာက Algorithm တစ်ခုပြုလုပ်တဲ့အချိန် ကြာချိန်ကို input အရွယ်အစားပေါ် မူတည်ပြီး ခန့်မှန်းဖော်ပြတဲ့အရာပဲ။\r\n\r\n### ဉပမာများ\r\n1. **Example 1: Constant Space Complexity (O(1))**\r\n\r\n```python\r\ndef get_first_element(n: list[any]):\r\n    return n[0]\r\n```\r\n\r\nဒီမှာကတော့ `get_first_element` ဆိုတဲ့ function တစ်ခုပါ။ သူက တခြား linear loop တွေလည်းမသုံးရသလို တစ်ခါတည်းနဲ့ပြီး (အချိန်မပြောင်း) တာမလို့ Access Time လို့လည်းခေါ်လို့ရတဲ့ Time Complexity တစ်ခုလည်းဖြစ်ပါတယ်။ သူက Time Complexity တွေထဲမှာအမြန်ဆုံးဖြစ်ပါတယ်။\r\n\r\n2. **Logarithmic Time Complexity (O(log n))**\r\n\r\n```python\r\ndef binary_search(arr: list[any], target: any) -> int:\r\n    low, high = 0, len(arr) - 1\r\n    while low <= high:\r\n        mid = (low + high) // 2\r\n        if arr[mid] == target:\r\n            return mid\r\n        elif arr[mid] < target:\r\n            low = mid + 1\r\n        else:\r\n            high = mid - 1\r\n    return -1\r\n```\r\n\r\nဒါကတော့ binary search algorithm တစ်ခုဖြစ်ပြီးတော့ logarithmic time complexity `O(log n)` ရှိပါတယ်။ သူက Linear Time Complexity `O(n)` ထက်မြန်ပါတယ်။\r\nပြောရမယ်ဆိုရင်တော့ input size `n` က grow လာသမျှတိုင်း steps တွေကလည်း logarithmically အရ problem ရဲ့ size `n` ကို တစ်၀က်ဖျက်သွားမှာပါ။\r\n\r\nဉပမာပြောရမယ်ဆိုရင်\r\n\r\n* Step 1 → 16 items\r\n* Step 2 → 8\r\n* Step 3 → 4\r\n* Step 4 → 2\r\n* Step 5 → 1\r\n\r\n3. **Linear Space Complexity** (O(n))\r\n\r\n```python\r\ndef add_all(arr: list[int]) -> int:\r\n    result = 0\r\n    for i in arr:\r\n        result = i + result\r\n    return result\r\n```\r\n\r\nဒီ function မှာဆိုရင် `add_all` ဆိုတဲ့ problem ကို solve ဖို့အတွက် `n` မှာပါသမျှကို သုံးရပါမယ် အဲ့တာကြောင့် arr ကိုတစ်ခါတည်း loop ရတာဖြစ်တဲ့အပြင် တခြား additional loop တွေမသုံးရတာကြောင့် Linear Time (O(n)) input size အတိုင်းသာ loop ဖြစ်ပါတယ်။\r\n\r\n## Space Complexity တွက်ခြင်း\r\n\r\n### ဥပမာများ\r\n\r\n1. **Constant Space Complexity** (O(1))\r\n\r\n```python\r\ndef add_numbers(a, b):\r\n    return a + b\r\n```\r\n\r\n`add_numbers` ဆိုတဲ့ function က input size (a, b) ဘယ်လောက်ပဲ ကြီးနေပါစေ additional memory ကိုထပ်မသုံးတာကြောင့် constant space complexity (`O(1)`) ဖြစ်ပါတယ်။\r\n\r\n2. **Example 2: Linear Space Complexity** (O(n))\r\n\r\n```python\r\ndef create_list(n):\r\n    arr = []\r\n    for i in range(n):\r\n        arr.append(i)\r\n    return arr\r\n```\r\n\r\n`create_list` ဆိုတဲ့ function မှာ input size n က `arr` ဆိုတဲ့ variable ကို n-size (input size) အဖြစ် memory size grow ဖြစ်တာကြောင့် linear space complexity, `O(n)` ဖြစ်ပါတယ်။.\r\n\r\n3. **Recursive Space Complexity**\r\n\r\n```python\r\ndef factorial(n):\r\n    if n == 0:\r\n        return 1\r\n    else:\r\n        return n * factorial(n - 1)\r\n```\r\n\r\nrecursive function က recursion depth (n) အထိ stack call memory ထဲမှာ result တွေကိုသိမ်းတာ ကြောင့်မလို့ O(n) space complexity ဖြစ်ပါတယ်။\r\n\r\nBig O Notation က algorithms ရဲ့ efficiency ဖို့ရည်ရွယ်ပါတယ်။ Big O Notation က algorithm တွေရဲ့ performance ကို input size နဲ့တူ duration နဲ့ memory (storage) ကို estimate လုပ်တဲ့ နေရာမှာ အရေးပါပါတယ်။\r\n\r\nLearn More: [Big O Cheat Sheet](https://www.bigocheatsheet.com/)",
    "title": "Big O Notation ဆိုတာဘာလဲ? (Beginner Guide)",
    "summary": "Algorithm ရဲ့ speed နဲ့ memory usage ကိုရှင်းပြတဲ့ Big O Notation ကို အလွယ်တကူနားလည်နိုင်အောင် ရေးသားထားပါတယ်။",
    "tags": [
      "what-is",
      "algorithms"
    ],
    "keywords": [
      "algorithms",
      "algorithm",
      "big-o",
      "big o notation"
    ],
    "publishedDate": new Date("2025-05-09T03:21:22.646Z"),
    "_meta": {
      "filePath": "what-is-big-o-notation-my.md",
      "fileName": "what-is-big-o-notation-my.md",
      "directory": ".",
      "extension": "md",
      "path": "what-is-big-o-notation-my"
    },
    "html": "<h1>Big O Notation ဆိုတာဘာလဲ</h1>\n<p><img src=\"https://www.bigocheatsheet.com/img/big-o-complexity-chart.png\" alt=\"Big O Notation Cheat Sheet\"></p>\n<p>Big O Notation ဆိုတာက algorithm selection နှင့် performance tuning လုပ်တဲ့အခါမှာ သုံးပါတယ်။ Big O Notation မှာ Time Complexity နဲ့  Space Complexity ဆိုပြီး နှစ်ခုရှိပါတယ်။</p>\n<p>Time Complexity ဆိုတာက algorithms တစ်ခုက input size ပေါ် မှာမူတည်ပြီး algorithm ကို run estimated duration ကိုပြောတာပါ။</p>\n<p>Space complexity ဆိုတာ algorithm တစ်ခုကို run တဲ့အခါမှာ required memory amount (bytes, kilobytes, etc.) ကို input size (n) ပေါ် မှာမူတည်ပြီး ခန့်မှုန်းတဲ့နေရာမှာသုံး ပါတယ်။</p>\n<p>Big O Notation ဆိုတာကဟာ Programmer တိုင်းသိထားသင့်တဲ့ mathematical notation တစ်ခုဖြစ်ပါတယ်။ Code ရေးတတ်တာ alone နဲ့ မလုံလောက်ဘူး။ Algorithm ရဲ့ performance နားလည်ဖို့ Big O Notation သိထားသင့်တယ်။</p>\n<h2>Time Complexity တွက်ခြင်း</h2>\n<p>Time Complexity ဆိုတာက Algorithm တစ်ခုပြုလုပ်တဲ့အချိန် ကြာချိန်ကို input အရွယ်အစားပေါ် မူတည်ပြီး ခန့်မှန်းဖော်ပြတဲ့အရာပဲ။</p>\n<h3>ဉပမာများ</h3>\n<ol>\n<li><strong>Example 1: Constant Space Complexity (O(1))</strong></li>\n</ol>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_first_element</span>(<span class=\"hljs-params\">n: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">any</span>]</span>):\r\n    <span class=\"hljs-keyword\">return</span> n[<span class=\"hljs-number\">0</span>]\n</code></pre>\n<p>ဒီမှာကတော့ <code>get_first_element</code> ဆိုတဲ့ function တစ်ခုပါ။ သူက တခြား linear loop တွေလည်းမသုံးရသလို တစ်ခါတည်းနဲ့ပြီး (အချိန်မပြောင်း) တာမလို့ Access Time လို့လည်းခေါ်လို့ရတဲ့ Time Complexity တစ်ခုလည်းဖြစ်ပါတယ်။ သူက Time Complexity တွေထဲမှာအမြန်ဆုံးဖြစ်ပါတယ်။</p>\n<ol start=\"2\">\n<li><strong>Logarithmic Time Complexity (O(log n))</strong></li>\n</ol>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">binary_search</span>(<span class=\"hljs-params\">arr: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">any</span>], target: <span class=\"hljs-built_in\">any</span></span>) -> <span class=\"hljs-built_in\">int</span>:\r\n    low, high = <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(arr) - <span class=\"hljs-number\">1</span>\r\n    <span class=\"hljs-keyword\">while</span> low &#x3C;= high:\r\n        mid = (low + high) // <span class=\"hljs-number\">2</span>\r\n        <span class=\"hljs-keyword\">if</span> arr[mid] == target:\r\n            <span class=\"hljs-keyword\">return</span> mid\r\n        <span class=\"hljs-keyword\">elif</span> arr[mid] &#x3C; target:\r\n            low = mid + <span class=\"hljs-number\">1</span>\r\n        <span class=\"hljs-keyword\">else</span>:\r\n            high = mid - <span class=\"hljs-number\">1</span>\r\n    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>\n</code></pre>\n<p>ဒါကတော့ binary search algorithm တစ်ခုဖြစ်ပြီးတော့ logarithmic time complexity <code>O(log n)</code> ရှိပါတယ်။ သူက Linear Time Complexity <code>O(n)</code> ထက်မြန်ပါတယ်။\r\nပြောရမယ်ဆိုရင်တော့ input size <code>n</code> က grow လာသမျှတိုင်း steps တွေကလည်း logarithmically အရ problem ရဲ့ size <code>n</code> ကို တစ်၀က်ဖျက်သွားမှာပါ။</p>\n<p>ဉပမာပြောရမယ်ဆိုရင်</p>\n<ul>\n<li>Step 1 → 16 items</li>\n<li>Step 2 → 8</li>\n<li>Step 3 → 4</li>\n<li>Step 4 → 2</li>\n<li>Step 5 → 1</li>\n</ul>\n<ol start=\"3\">\n<li><strong>Linear Space Complexity</strong> (O(n))</li>\n</ol>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_all</span>(<span class=\"hljs-params\">arr: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]</span>) -> <span class=\"hljs-built_in\">int</span>:\r\n    result = <span class=\"hljs-number\">0</span>\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> arr:\r\n        result = i + result\r\n    <span class=\"hljs-keyword\">return</span> result\n</code></pre>\n<p>ဒီ function မှာဆိုရင် <code>add_all</code> ဆိုတဲ့ problem ကို solve ဖို့အတွက် <code>n</code> မှာပါသမျှကို သုံးရပါမယ် အဲ့တာကြောင့် arr ကိုတစ်ခါတည်း loop ရတာဖြစ်တဲ့အပြင် တခြား additional loop တွေမသုံးရတာကြောင့် Linear Time (O(n)) input size အတိုင်းသာ loop ဖြစ်ပါတယ်။</p>\n<h2>Space Complexity တွက်ခြင်း</h2>\n<h3>ဥပမာများ</h3>\n<ol>\n<li><strong>Constant Space Complexity</strong> (O(1))</li>\n</ol>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_numbers</span>(<span class=\"hljs-params\">a, b</span>):\r\n    <span class=\"hljs-keyword\">return</span> a + b\n</code></pre>\n<p><code>add_numbers</code> ဆိုတဲ့ function က input size (a, b) ဘယ်လောက်ပဲ ကြီးနေပါစေ additional memory ကိုထပ်မသုံးတာကြောင့် constant space complexity (<code>O(1)</code>) ဖြစ်ပါတယ်။</p>\n<ol start=\"2\">\n<li><strong>Example 2: Linear Space Complexity</strong> (O(n))</li>\n</ol>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">create_list</span>(<span class=\"hljs-params\">n</span>):\r\n    arr = []\r\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\r\n        arr.append(i)\r\n    <span class=\"hljs-keyword\">return</span> arr\n</code></pre>\n<p><code>create_list</code> ဆိုတဲ့ function မှာ input size n က <code>arr</code> ဆိုတဲ့ variable ကို n-size (input size) အဖြစ် memory size grow ဖြစ်တာကြောင့် linear space complexity, <code>O(n)</code> ဖြစ်ပါတယ်။.</p>\n<ol start=\"3\">\n<li><strong>Recursive Space Complexity</strong></li>\n</ol>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">factorial</span>(<span class=\"hljs-params\">n</span>):\r\n    <span class=\"hljs-keyword\">if</span> n == <span class=\"hljs-number\">0</span>:\r\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>\r\n    <span class=\"hljs-keyword\">else</span>:\r\n        <span class=\"hljs-keyword\">return</span> n * factorial(n - <span class=\"hljs-number\">1</span>)\n</code></pre>\n<p>recursive function က recursion depth (n) အထိ stack call memory ထဲမှာ result တွေကိုသိမ်းတာ ကြောင့်မလို့ O(n) space complexity ဖြစ်ပါတယ်။</p>\n<p>Big O Notation က algorithms ရဲ့ efficiency ဖို့ရည်ရွယ်ပါတယ်။ Big O Notation က algorithm တွေရဲ့ performance ကို input size နဲ့တူ duration နဲ့ memory (storage) ကို estimate လုပ်တဲ့ နေရာမှာ အရေးပါပါတယ်။</p>\n<p>Learn More: <a href=\"https://www.bigocheatsheet.com/\">Big O Cheat Sheet</a></p>"
  }
]